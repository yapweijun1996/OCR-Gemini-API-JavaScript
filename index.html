<html>
	<head>
		<meta charset="utf-8" />
		<title>OCR with Google Gemini API</title>
		<style>
			body {
				font-family: Arial, sans-serif;
				margin: 20px;
			}
			#container {
				max-width: 600px;
				margin: 0 auto;
			}
			#uploadSection {
				margin-bottom: 20px;
			}
			.message {
				padding: 8px;
				margin-bottom: 10px;
				border-radius: 4px;
				white-space: break-spaces;
			}
			.user {
				background: #f0f0f0;
			}
			.system {
				background: #fff3cd;
			}
			.model {
				background: #d4edda;
			}
			#chatMessages {
				border: 1px solid #ddd;
				padding: 10px;
				max-height: 95vh;
				min-height: 10vh;
				overflow-y: auto;
			}
			#downloadContainer a {
				display: block;
				margin-top: 5px;
			}
			select {
				margin-left: 10px;
			}
		</style>
		<script src="script.js"></script>
	</head>
	<body>
		<div id="container">
			<h1>OCR with Google Gemini API</h1>
			<div id="uploadSection">
				<input type="file" id="imageInput" accept="image/*" />
				<!-- Add a dropdown for model selection -->
				<select id="modelSelect">
					<option value="gemini-2.0-flash">gemini-2.0-flash</option>
					<option value="gemma-3-27b-it">gemma-3-27b-it</option>
				</select>
				<button id="sendBtn">Perform OCR</button>
			</div>
			<div id="chatMessages"></div>
			<div id="downloadContainer"></div>
		</div>
		<script>
			
			// Simple configuration for Gemini API
			const generationConfig = {
				temperature: 1,
				topP: 0.95,
				topK: 40,
				maxOutputTokens: 8192,
				responseMimeType: "text/plain"
			};
			
			let chatHistory = [];
			
			// Start a chat session for the selected model
			async function startChatSession(selectedModel) {
				return {
					sendMessage: async function(messageData) {
						let userMessage =
						typeof messageData === "string"
						? { role: "user", parts: [{ text: messageData }] }
						: messageData;
						const requestBody = {
							contents: [...chatHistory, userMessage],
							generationConfig
						};
						const url =
						"https://generativelanguage.googleapis.com/v1beta/models/" +
						selectedModel +
						":generateContent?key=" +
						apiKey;
						const response = await fetch(url, {
							method: "POST",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify(requestBody)
						});
						if (!response.ok)
						throw new Error("API error " + response.status);
						const result = await response.json();
						if (result.candidates && result.candidates.length > 0) {
							const modelResponse = {
								role: "model",
								parts: result.candidates[0].content.parts
							};
							chatHistory.push(userMessage, modelResponse);
						} else {
							throw new Error("No response from API");
						}
						return result;
					}
				};
			}
			
			// Convert file to Base64 string
			function readFileAsBase64(file) {
				return new Promise((resolve, reject) => {
					const reader = new FileReader();
					reader.onload = () =>
					resolve(reader.result.split(",")[1]);
					reader.onerror = reject;
					reader.readAsDataURL(file);
				});
			}
			
			// Process inline data if returned from API (e.g., download links)
			function processInlineData(result) {
				const container = document.getElementById("downloadContainer");
				container.innerHTML = "";
				if (result.candidates) {
					result.candidates.forEach((cand, i) => {
						cand.content.parts.forEach((part, j) => {
							if (part.inline_data) {
								const bytes = atob(part.inline_data.data);
								let byteNumbers = [];
								for (let k = 0; k < bytes.length; k++) {
									byteNumbers.push(bytes.charCodeAt(k));
								}
								const blob = new Blob(
								[new Uint8Array(byteNumbers)],
								{ type: part.inline_data.mime_type }
								);
								const url = URL.createObjectURL(blob);
								const ext =
								part.inline_data.mime_type.split("/")[1] || "bin";
								const link = document.createElement("a");
								link.href = url;
								link.download = "output_" + i + "_" + j + "." + ext;
								link.textContent = "Download " + link.download;
								container.appendChild(link);
							}
						});
					});
				}
			}
			
			// Append a message to the chat area
			function appendMessage(role, text) {
				const chatMessages = document.getElementById("chatMessages");
				const msgDiv = document.createElement("div");
				msgDiv.className = "message " + role;
				msgDiv.textContent = text;
				chatMessages.appendChild(msgDiv);
				chatMessages.scrollTop = chatMessages.scrollHeight;
			}
			
			// Run OCR by sending the image and OCR instruction to the API
			async function runOCR() {
				const imageInput = document.getElementById("imageInput");
				const imageFile = imageInput.files[0];
				if (!imageFile) {
					alert("Please upload an image.");
					return;
				}
				appendMessage("user", "Uploaded image: " + imageFile.name);
				appendMessage("system", "Processing image for OCR...");
				
				let parts = [];
				try {
					const base64Data = await readFileAsBase64(imageFile);
					// Send OCR instruction along with the image data
					parts.push({
						text: "Extract text from the given image. The output text format must follow same as the given image."
					});
					parts.push({
						inline_data: {
							data: base64Data,
							mime_type: imageFile.type
						}
					});
				} catch (err) {
					appendMessage("system", "Error reading image.");
					return;
				}
				const userMessage = { role: "user", parts };
				
				try {
					// Get model selection from dropdown
					const modelSelect = document.getElementById("modelSelect");
					const selectedModel = modelSelect.value;
					const session = await startChatSession(selectedModel);
					const result = await session.sendMessage(userMessage);
					// Remove the "Processing..." system message (last message)
					const chatMessages = document.getElementById("chatMessages");
					chatMessages.removeChild(chatMessages.lastChild);
					if (result.candidates && result.candidates.length > 0) {
						const candidate = result.candidates[0];
						const textResponse = candidate.content.parts
						.filter(p => p.text)
						.map(p => p.text)
						.join("\n");
						appendMessage("model", textResponse || "No text response.");
						processInlineData(result);
					}
				} catch (err) {
					appendMessage("system", "Error: " + err.message);
				}
			}
			
			// Event listener for OCR button
			document.getElementById("sendBtn").addEventListener("click", runOCR);
		</script>
	</body>
</html>